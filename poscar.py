"""
Representing POSCAR file class as specified in VASP manual
"""

class poscar():
  
  # Constructor operator
  def __init__(self, paraDict):
    self.paraDict = paraDict

  # Convert the poscar to unitcell, return a unitcell
  def convertToUnitcell(self):
    from coor import coor
    paraDict = self.paraDict
    s = paraDict['scalingFactor']
    a = coor(tuple(paraDict['latticeVectors'][0]))
    b = coor(tuple(paraDict['latticeVectors'][1]))
    c = coor(tuple(paraDict['latticeVectors'][2]))
    speciesNumber = paraDict['speciesNumber']
    speciesLabel = paraDict['speciesLabel']
    coordinateSystem = paraDict['coordinateSystem']
    atomPositions = paraDict['atomPositions']
    # Get the total number of atoms specified in poscar
    atomNumberCount = sum(speciesNumber)
    # Scale the latticeMatrix
    a = a * s; b = b * s; c = c * s;
    # Construct the siteList (Recall that unitcell always use reduced coor)
    from element import element
    elementList = [element(speciesLabel[index])\
                  for index in range(len(speciesLabel))\
                  for count in range(speciesNumber[index])]
    if coordinateSystem == 'Direct':
      reducedCoorList = [coor(tuple(position)) for position in atomPositions]
    else:
      raise StandardError("Coordinate system not direct")
    from atom import atom
    alist = [atom(element, coor)\
               for (element, coor) in zip(elementList, reducedCoorList)]
    from unitcell import unitcell
    return unitcell(a, b, c, alist)

  # Parsing POSCARS and return an instance of poscar
  @staticmethod
  def parse(fileName):

    poscarFileHandle = open(fileName, 'r')

    paraDict = {}

    # First line is the commentLine
    commentLine = poscarFileHandle.readline().lstrip()

    # Second line provides a universal scaling factor
    scalingFactorString = poscarFileHandle.readline()
    scalingFactor = float(scalingFactorString)
    paraDict['scalingFactor'] = scalingFactor

    # Third line to fifth line are the scaled lattice vectors
    latticeVectors = []
    for dimension in range(3):
      latticeVectorString = poscarFileHandle.readline()
      latticeVectors.append(map(float, latticeVectorString.split()))
    paraDict['latticeVectors'] = latticeVectors

    # Since if speciesLabel are not provided
    # We are unable to completely define unitCell with the poscar
    # Let's assume speciesLable must be provided
    speciesString = poscarFileHandle.readline()

    speciesLabel = speciesString.split()
    # Next line is the number of individual species
    speciesString = poscarFileHandle.readline()
    speciesNumber = map(int, speciesString.split())

    paraDict['speciesLabel'] = speciesLabel
    paraDict['speciesNumber'] = speciesNumber

    numberOfAtoms = int(sum(speciesNumber))
    paraDict['numberOfAtoms'] = numberOfAtoms

    # Default selective dynamics is False if no additional
    # info is provided when handling coordinates
    paraDict['selectiveDynamics'] = False

    nextLine = poscarFileHandle.readline().lstrip()
    while nextLine:
      # Modify and return the paraDict for each line
      paraDict = poscar.handleCoor(nextLine, paraDict, poscarFileHandle)
      nextLine = poscarFileHandle.readline().lstrip()

    return poscar(paraDict)

  # Write out the poscar, pos to fileName
  def write(self, fileName, overwrite = True):
    import os.path
    # Make sure it leaves the loop with overwriting
    while not overwrite:
      if os.path.isfile(fileName):
        print "Are you sure you want to overwrite %s? (y/n)" %(fileName)
        ans = raw_input()
        if ans == 'y':
          overwrite = True
        else:
          fileName = raw_input("Enter a new file name")
      else:
        overwrite = True

    poscarFileHandle = open(fileName, 'w')
    paraDict = self.paraDict

    # Follow the standard format in VASP manual
    # First line is the comment line
    print >> poscarFileHandle, "Generated by pycell"
    # Second line provides a universal scaling factor
    print >> poscarFileHandle, "%8.6f" %(paraDict['scalingFactor'])
    # Third line to Fifth line are the scaled lattice vectors
    for latticeVector in paraDict['latticeVectors']:
      print >> poscarFileHandle, "   %16.14f   %16.14f   %16.14f"\
      %(latticeVector[0], latticeVector[1], latticeVector[2])
    # write speciesLabel
    print >> poscarFileHandle, " ".join(paraDict['speciesLabel'])
    # write speciesNumber
    print >> poscarFileHandle, " ".join(map(str, paraDict['speciesNumber']))
    # write coordinate system
    print >> poscarFileHandle, paraDict['coordinateSystem']
    # write atomPositions
    for position in paraDict['atomPositions']:
      print >> poscarFileHandle, "   %16.14f   %16.14f   %16.14f"\
      %(position[0], position[1], position[2])

  # Handle the coordinate lines including the coordinate system line
  @staticmethod
  def handleCoor(line, paraDict, poscarFileHandle):
    # We have to know the number of atoms to proceed
    numberOfAtoms = paraDict['numberOfAtoms']
    # For selective dynamics
    if line[0] == 's' or line[0] == 'S':
      paraDict['selectiveDynamics'] = True
    # If the line is not SD line
    else:
      if line[0] == 'k' or line[0] == 'K' or line[0] == 'c' or line[0] == 'C':
        paraDict['coordinateSystem'] = 'Cartesian'
      if line[0] == 'd' or line[0] == 'D':
        paraDict['coordinateSystem'] = 'Direct'
      # Update the atomic positions and specific SD booleans
      [atomPositions, specSelectiveDynamics]  = \
        poscar.parseAtomPos(numberOfAtoms, \
        paraDict['selectiveDynamics'], poscarFileHandle)
      paraDict['atomPositions'] = atomPositions
      paraDict['specSelectiveDynamics'] = specSelectiveDynamics
    return paraDict

  # Parsing the atomic positions and update
  # atomic positions and selectiveDynamics
  @staticmethod
  def parseAtomPos(numberOfAtoms, selectiveDynamics, poscarFileHandle):
    atomPositions = []; specSelectiveDynamics = [];
    # atomNumber is an integer index
    for atomNumber in range(numberOfAtoms):
      # This string includes the tags for SD
      atomPositionString = poscarFileHandle.readline()
      atomPositionList = atomPositionString.split()
      if selectiveDynamics:
        # Raise error if the length of the string.split() is not 6
        if len(atomPositionList) != 6:
          raise ValueError(\
          'POSCAR parsing error: Atom position with SD length != 6')
        # The first three should be the positions coordinates
        atomPositions.append(map(float, atomPositionList[0:3]))
        # Remember that it is still string TODO
        specSelectiveDynamics.append(atomPositionList[3:6])
      else:
        if len(atomPositionList) != 3:
          raise ValueError(\
          'POSCAR parsing error: Atom position length != 3')
        atomPositions.append(map(float, atomPositionList))
        # specSeletiveDynamics left empty list
    return [atomPositions, specSelectiveDynamics]

  # Return a poscar instance constructed from parameters
  @staticmethod
  def initFromPara(scalingFactor, latticeVectors, speciesLabel,\
                        speciesNumber, selectiveDynamics, coordinateSystem,\
                        atomPositions):
    paraDict = {}
    paraDict['scalingFactor'] = scalingFactor
    paraDict['latticeVectors'] = latticeVectors
    paraDict['speciesLabel'] = speciesLabel
    paraDict['speciesNumber'] = speciesNumber
    paraDict['selectiveDynamics'] = selectiveDynamics
    paraDict['coordinateSystem'] = coordinateSystem
    paraDict['atomPositions'] = atomPositions
    return poscar(paraDict)
